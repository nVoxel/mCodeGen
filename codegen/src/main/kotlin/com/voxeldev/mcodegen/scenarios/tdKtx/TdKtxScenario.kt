package com.voxeldev.mcodegen.scenarios.tdKtx

import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.voxeldev.mcodegen.GlobalConstants
import com.voxeldev.mcodegen.interfaces.Scenario
import com.voxeldev.mcodegen.scenarios.tdKtx.generators.FunctionsGenerator
import com.voxeldev.mcodegen.scenarios.tdKtx.generators.UpdatesGenerator
import com.voxeldev.mcodegen.utils.GlobalFileUtils
import com.voxeldev.mcodegen.utils.GlobalFileUtils.asString
import com.voxeldev.mcodegen.utils.GlobalTelegramApiUtils
import org.jetbrains.kotlin.com.intellij.psi.PsiClass
import org.jetbrains.kotlin.com.intellij.psi.PsiJavaFile
import java.nio.file.Paths

object TdKtxScenario : Scenario {

    override fun run() {
        val file = GlobalTelegramApiUtils.getAndroidTelegramApiFile()
        val codeString = file.asString()
        val ktFile: PsiJavaFile = GlobalFileUtils.parseJavaFile(codeString, file.name)
        val tdapi: PsiClass = ktFile.classes[0]
        val allClasses: Array<PsiClass> = tdapi.innerClasses

        val javaFunctions = allClasses.filter {
            it.extendsList?.referencedTypes?.firstOrNull()?.name == "Function"
        }

        val objects = allClasses.filter {
            it.extendsList?.referencedTypes?.firstOrNull()?.name == "Object"
        }

        val javaUpdates = allClasses.filter {
            it.extendsList?.referencedTypes?.firstOrNull()?.name == "Update"
        }

        val functions = translateJavaToKt(javaFunctions, objects, FunctionsGenerator::generateFunction)

        val functionsFilesMap = FunctionsGenerator.mapFunctionsByFile(objects, functions)

        writeExtFuncFilesByMap(functionsFilesMap, TdKtxScenarioConstants.FUNCTIONS_PACKAGE, "FunctionsKtx")

        val updates = translateJavaToKtWithImports(javaUpdates, UpdatesGenerator::generateUpdate)

        val updatesFileMap = UpdatesGenerator.mapUpdatesByFile(objects, updates)

        writeExtFuncFilesByMapWithImports(updatesFileMap, TdKtxScenarioConstants.FLOW_PACKAGE, "UpdatesKtx")
    }

    private fun writeExtFuncFilesByMap(
        filesMap: HashMap<String, List<FunSpec>>,
        packageName: String,
        nameSuffix: String
    ) {
        filesMap.forEach { (name, functions) ->
            val file = FileSpec.builder(
                packageName = packageName, //.${function.getResultName().decapitalize()}
                fileName = name + nameSuffix
            )
                .addComment(
                    "\nNOTE: THIS FILE IS AUTO-GENERATED by the TdApiKtxGenerator.kt\n" +
                            "See: https://github.com/tdlibx/td-ktx-generator/\n"
                )
                .addImport(
                    TdKtxScenarioConstants.CORE_PACKAGE,
                    TdKtxScenarioConstants.API_NAME
                )
                .apply {
                    functions.forEach { addFunction(it) }
                }
                .build()

            file.writeTo(Paths.get(TdKtxScenarioConstants.ktxOutputPath))
        }
    }

    private fun writeExtFuncFilesByMapWithImports(
        filesMap: HashMap<String, List<Pair<FunSpec, List<String>>>>,
        packageName: String,
        nameSuffix: String
    ) {
        filesMap.forEach { (name, functions) ->
            val file = FileSpec.builder(
                packageName = packageName, //.${function.getResultName().decapitalize()}
                fileName = name + nameSuffix
            )
                .addComment(
                    "\nNOTE: THIS FILE IS AUTO-GENERATED by the TdApiKtxGenerator.kt\n" +
                            "See: https://github.com/tdlibx/td-ktx-generator/\n"
                )
                .addImport(
                    TdKtxScenarioConstants.CORE_PACKAGE,
                    TdKtxScenarioConstants.API_NAME
                )
                .apply {
                    functions.forEach { func ->
                        func.second.forEach { addImport(GlobalConstants.TGDRIVE_PACKAGE, it) }
                    }
                    functions.forEach { addFunction(it.first) }
                }
                .build()

            file.writeTo(Paths.get(TdKtxScenarioConstants.ktxOutputPath))
        }
    }

    private fun translateJavaToKt(
        classes: List<PsiClass>,
        objects: List<PsiClass>,
        convert: (List<PsiClass>, PsiClass) -> FunSpec
    ): List<FunSpec> {
        return classes.map { function ->
            val func = convert(objects, function)
            func
        }
    }

    private fun translateJavaToKtWithImports(
        classes: List<PsiClass>,
        convert: (PsiClass) -> Pair<FunSpec, List<String>>
    ): List<Pair<FunSpec, List<String>>> {
        return classes.map { function -> convert(function) }
    }
}